% import data
rawData = csvread("Concrete_Data.csv", 1, 0);
% cuts out the top row since (1) it's names, keeps leftmost column as its
% data

% standardizing with a z score
standardizedData = zscore(rawData);

a_standardized = standardizedData(:,1:end-1); % extract all but far right column
c_standardized = standardizedData(:,end); %extract last column

% to create an intercept
a_intercept = [rawData(:,1:end-1) ones([size(rawData,1),1])];
c_intercept = rawData(:,end);

% we're gonna use the standardized data

%Calculate w vector
% w is the solution to A*w = c,
w_standardized = a_standardized\c_standardized;

% Using our prediction vector, calculate what c should be
% Predict the c vector using our w vector
c_standardized_prediction = a_standardized * w_standardized;

% Calculate RMS to see how well we did\

rms_standardized = rms(c_standardized - c_standardized_prediction)



% Now lets do the same thing with the intercept term

%Calculate the w vector
w_intercept = a_intercept\c_intercept;

% Calculate the predicted c using our w vector
c_intercept_prediction = a_intercept*w_intercept;

% Calculate RMS to compare to standardized data
%rms_intercept = rms(c_intercept - c_intercept_prediction);

% Peform 3 - cross fold validation

k = 3; % I believe this corresponds to the 3 cross fold validation

% We need to split up the 'folds', because we need to shuffle data
rng('default') % this makes sure the random seed we get each time is the same, so it doesn't change across runs

% so we are getting numbers between 1 and 1030, and creating a random 
% permutation of that
random_index = randperm(linspace(1, size(rawData,1),1));

a_standardized_permutation = a_standardized(random_index, :); % rearrange the vector to be in the random order generated by randperm above
c_standardized_permutation = c_standardized(random_index, :); % rearrange the vector to be in the random order generated by randperm above

% Determine how many rows for our experiment
number_in_fold = round(size(rawData, 1)/k); % take 

% Form an empty matrix to hold the RMS train and test results
rms_errors = zeros(k,2); % each row is a fold

current_test_start = 1; % a mutating variable, specifying the index we are on for the current test

% first third of sample is testing data

a1_test = a_standardized_permutation(1:number_in_fold, :); % take 1 to 343 rows, all columns
c1_test = c_standardized_permutation(1:number_in_fold, :); % take 1 to 343 rows, all columns

% second two thirds are training data

a1_train = a_standardized_permutation((number_in_fold+1):end, :);
c1_train = c_standardized_permutation((number_in_fold+1):end, :);

% perform the regression with the training data

w1_standardized = a1_train\c1_train;
rms_train = rms(c1_train - a1_train*w1_standardized);
rms_test = rms(c1_test - a1_test*w1_standardized);

rms_errors(1,:) = [rms_train, rms_test]

% do the same test again with the other numbers

current_test_start = current_test_start + number_in_fold;
current_test_end = current_test_start + number_in_fold;

% now we do some weird 'logical' array,

test2_indices = false(size(rawData, 1),1); % create 1030 0s
test2_indices(current_test_start:current_test_end) =1; % make relevant indices for test 2 equal to 1

%reverse this for the training data

train2_indices = true(size(rawData, 1),1); % create 1030 1s
train2_indices(current_test_start:current_test_end) = 0;

% extract data for training and testing 

a2_test = a_standardized_permutation(test2_indices,:); % grab all the indexes that are 1
c2_test = c_standardized_permutation(test2_indices,:);

a2_train = a_standardized_permutation(train2_indices,:);
c2_train = c_standardized_permutation(train2_indices,:);

% perform regression

w2_standardized = a2_train\c2_train;

rms_train = rms(c2_train - a2_train*w1_standardized);
rms_test = rms(c2_test - a2_test*w1_standardized);

rms_errors(2,:) = [rms_train, rms_test]



% NOW THIRD TEST

current_test_start = current_test_start + number_in_fold;
current_test_end = current_test_start + number_in_fold;

% now we do some weird 'logical' array,

test3_indices = false(size(rawData, 1),1); % create 1030 0s
test3_indices(current_test_start:current_test_end) =1; % make relevant indices for test 3 equal to 1

%reverse this for the training data

train3_indices = true(size(rawData, 1),1); % create 1030 1s
train3_indices(current_test_start:current_test_end) = 0;

% extract data for training and testing 

a3_test = a_standardized_permutation(test3_indices,:); % grab all the indexes that are 1
c3_test = c_standardized_permutation(test3_indices,:);

a3_train = a_standardized_permutation(train3_indices,:);
c3_train = c_standardized_permutation(train3_indices,:);

% perform regression

w3_standardized = a3_train\c3_train;

rms_train = rms(c3_train - a3_train*w1_standardized);
rms_test = rms(c3_test - a3_test*w1_standardized);

rms_errors(3,:) = [rms_train, rms_test]


rms_train_results = rms_errors(:,1)  


